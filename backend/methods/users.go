/*
Copyright (C) 2025 Nethesis S.r.l.
SPDX-License-Identifier: AGPL-3.0-or-later
*/

package methods

import (
	"errors"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/gin-gonic/gin/binding"

	"github.com/nethesis/my/backend/cache"
	"github.com/nethesis/my/backend/entities"
	"github.com/nethesis/my/backend/helpers"
	"github.com/nethesis/my/backend/logger"
	"github.com/nethesis/my/backend/models"
	"github.com/nethesis/my/backend/response"
	"github.com/nethesis/my/backend/services/local"
)

// CreateUser handles POST /api/users - creates a new user locally and syncs to Logto
func CreateUser(c *gin.Context) {
	// Parse request body
	var request models.CreateLocalUserRequest
	if err := c.ShouldBindBodyWith(&request, binding.JSON); err != nil {
		c.JSON(http.StatusBadRequest, response.ValidationBadRequestMultiple(err))
		return
	}

	// Password will be auto-generated by the service

	// Get current user context
	user, ok := helpers.GetUserFromContext(c)
	if !ok {
		return
	}

	// Create service
	service := local.NewUserService()

	// Validate permissions
	userOrgRole := strings.ToLower(user.OrgRole)
	if canCreate, reason := service.CanCreateUser(userOrgRole, user.OrganizationID, &request); !canCreate {
		c.JSON(http.StatusForbidden, response.Forbidden("access denied: "+reason, nil))
		return
	}

	// Validate role assignment permissions if roles are being assigned
	if len(request.UserRoleIDs) > 0 {
		roleCache := cache.GetRoleNames()
		if !roleCache.IsLoaded() {
			logger.Error().
				Str("current_user_id", user.ID).
				Msg("Role cache not loaded - cannot validate role assignments")
			c.JSON(http.StatusInternalServerError, response.InternalServerError("role validation unavailable", nil))
			return
		}

		// Check each role being assigned
		for _, roleID := range request.UserRoleIDs {
			accessControl, exists := roleCache.GetAccessControl(roleID)
			if exists && accessControl.HasAccessControl {
				// This role has access control restrictions
				hasPermission := HasOrgRolePermission(user.OrgRole, accessControl.RequiredOrgRole)
				if !hasPermission {
					logger.RequestLogger(c, "users").Warn().
						Str("operation", "role_assignment_denied").
						Str("current_user_id", user.ID).
						Str("current_user_org_role", user.OrgRole).
						Str("role_id", roleID).
						Str("required_org_role", accessControl.RequiredOrgRole).
						Msg("User attempted to assign role without sufficient privileges")

					c.JSON(http.StatusForbidden, response.Forbidden("insufficient privileges to assign this role", map[string]interface{}{
						"role_id":           roleID,
						"required_org_role": strings.ToLower(accessControl.RequiredOrgRole),
						"current_org_role":  strings.ToLower(user.OrgRole),
					}))
					return
				}

				logger.RequestLogger(c, "users").Debug().
					Str("operation", "role_assignment_validated").
					Str("current_user_id", user.ID).
					Str("current_user_org_role", user.OrgRole).
					Str("role_id", roleID).
					Str("required_org_role", accessControl.RequiredOrgRole).
					Msg("Role assignment validated successfully")
			}
		}
	}

	// Create user
	account, err := service.CreateUser(&request, user.ID, user.OrganizationID)
	if err != nil {
		// Check if it's a validation error from service
		if validationErr := getValidationError(err); validationErr != nil {
			logger.Warn().
				Str("user_id", user.ID).
				Str("user_username", request.Username).
				Str("validation_reason", validationErr.ErrorData.Errors[0].Message).
				Msg("User creation validation failed")

			c.JSON(http.StatusBadRequest, response.ValidationFailed("validation failed", validationErr.ErrorData.Errors))
			return
		}

		// System error - log as error
		logger.Error().
			Err(err).
			Str("user_id", user.ID).
			Str("user_username", request.Username).
			Msg("Failed to create user")

		// Default to internal server error
		c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to create user", map[string]interface{}{
			"error": err.Error(),
		}))
		return
	}

	// Log the action
	logger.LogBusinessOperation(c, "users", "create", "user", account.ID, true, nil)

	// Return success response
	c.JSON(http.StatusCreated, response.Created("user created successfully", account))
}

// GetUser handles GET /api/users/:id - retrieves a single user account
func GetUser(c *gin.Context) {
	// Get user ID from URL parameter
	userID := c.Param("id")
	if userID == "" {
		c.JSON(http.StatusBadRequest, response.BadRequest("user ID required", nil))
		return
	}

	// Get current user context
	user, ok := helpers.GetUserFromContext(c)
	if !ok {
		return
	}

	// Get user account
	repo := entities.NewLocalUserRepository()
	account, err := repo.GetByID(userID)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			c.JSON(http.StatusNotFound, response.NotFound("user not found", nil))
			return
		}

		logger.Error().
			Err(err).
			Str("current_user_id", user.ID).
			Str("target_user_id", userID).
			Msg("Failed to get user")

		c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to get user", nil))
		return
	}

	// Apply RBAC validation
	userOrgRole := strings.ToLower(user.OrgRole)
	canAccess := false

	// Users can always see themselves
	if userID == user.ID {
		canAccess = true
	} else {
		// Check organization-based access
		targetOrgID := ""
		if account.OrganizationID != nil {
			targetOrgID = *account.OrganizationID
		}

		switch userOrgRole {
		case "owner":
			canAccess = true
		case "distributor":
			// Distributor can see users in their organization and customer organizations they manage
			if targetOrgID == user.OrganizationID {
				canAccess = true
			}
			// Additional logic needed to check customer organizations
		case "reseller":
			// Reseller can see users in their organization
			if targetOrgID == user.OrganizationID {
				canAccess = true
			}
		case "customer":
			// Customer can only see users in their own organization
			if targetOrgID == user.OrganizationID {
				canAccess = true
			}
		}
	}

	if !canAccess {
		c.JSON(http.StatusForbidden, response.Forbidden("access denied to user", nil))
		return
	}

	// Log the action
	logger.RequestLogger(c, "users").Info().
		Str("operation", "get_user").
		Str("user_id", userID).
		Msg("User details requested")

	// Return user account
	c.JSON(http.StatusOK, response.OK("user retrieved successfully", account))
}

// GetUsers handles GET /api/users - list accounts with pagination
func GetUsers(c *gin.Context) {
	// Get current user context
	user, ok := helpers.GetUserFromContext(c)
	if !ok {
		return
	}

	// Parse pagination and sorting parameters
	page, pageSize, sortBy, sortDirection := helpers.GetPaginationAndSortingFromQuery(c)

	// Parse search parameter
	search := c.Query("search")

	// Create service
	service := local.NewUserService()

	// Get users based on RBAC (exclude current user)
	userOrgRole := strings.ToLower(user.OrgRole)
	accounts, totalCount, err := service.ListUsers(userOrgRole, user.OrganizationID, user.ID, page, pageSize, search, sortBy, sortDirection)
	if err != nil {
		logger.Error().
			Err(err).
			Str("user_id", user.ID).
			Str("user_org_role", userOrgRole).
			Msg("Failed to list users")

		c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to list users", nil))
		return
	}

	// Check if current user has impersonate permission (from user roles or organization roles)
	canImpersonate := HasPermission(user.UserPermissions, user.OrgPermissions, "impersonate:users")

	// Enrich users with impersonation consent status if user can impersonate
	var enrichedUsers []gin.H
	if canImpersonate {
		impersonationService := local.NewImpersonationService()

		// Collect all user IDs for batch consent check (performance optimization)
		userIDs := make([]string, len(accounts))
		for i, account := range accounts {
			userIDs[i] = account.ID
		}

		// Batch check impersonation consent for all users (single query instead of N queries)
		consentMap, err := impersonationService.CanBeImpersonatedBatch(userIDs)
		if err != nil {
			logger.RequestLogger(c, "users").Warn().
				Err(err).
				Int("user_count", len(userIDs)).
				Msg("Failed to batch check impersonation consent, defaulting to false")
			// Initialize empty map so all users default to false
			consentMap = make(map[string]bool)
		}

		for _, account := range accounts {
			// Get consent status from batch result (defaults to false if not found)
			canBeImpersonated := consentMap[account.ID]

			// Convert account to gin.H and add impersonation field
			userMap := gin.H{
				"id":                  account.ID,
				"logto_id":            account.LogtoID,
				"username":            account.Username,
				"email":               account.Email,
				"name":                account.Name,
				"phone":               account.Phone,
				"organization":        account.Organization,
				"roles":               account.Roles,
				"custom_data":         account.CustomData,
				"created_at":          account.CreatedAt,
				"updated_at":          account.UpdatedAt,
				"logto_synced_at":     account.LogtoSyncedAt,
				"latest_login_at":     account.LatestLoginAt,
				"deleted_at":          account.DeletedAt,
				"suspended_at":        account.SuspendedAt,
				"can_be_impersonated": canBeImpersonated,
			}
			enrichedUsers = append(enrichedUsers, userMap)
		}
	} else {
		// For non-Owner users, just convert to gin.H without impersonation field
		for _, account := range accounts {
			userMap := gin.H{
				"id":              account.ID,
				"logto_id":        account.LogtoID,
				"username":        account.Username,
				"email":           account.Email,
				"name":            account.Name,
				"phone":           account.Phone,
				"organization":    account.Organization,
				"roles":           account.Roles,
				"custom_data":     account.CustomData,
				"created_at":      account.CreatedAt,
				"updated_at":      account.UpdatedAt,
				"logto_synced_at": account.LogtoSyncedAt,
				"latest_login_at": account.LatestLoginAt,
				"deleted_at":      account.DeletedAt,
				"suspended_at":    account.SuspendedAt,
			}
			enrichedUsers = append(enrichedUsers, userMap)
		}
	}

	// Log the action
	logger.RequestLogger(c, "users").Info().
		Str("operation", "list_users").
		Int("page", page).
		Int("page_size", pageSize).
		Str("search", search).
		Int("total_count", totalCount).
		Int("returned_count", len(accounts)).
		Bool("can_impersonate", canImpersonate).
		Msg("Users list requested")

	// Return paginated response with enriched data
	c.JSON(http.StatusOK, response.PaginatedWithSorting("users retrieved successfully", "users", enrichedUsers, totalCount, page, pageSize, sortBy, sortDirection))
}

// UpdateUser handles PUT /api/users/:id - updates a user account locally and syncs to Logto
func UpdateUser(c *gin.Context) {
	// Get user ID from URL parameter
	userID := c.Param("id")
	if userID == "" {
		c.JSON(http.StatusBadRequest, response.BadRequest("user ID required", nil))
		return
	}

	// Parse request body
	var request models.UpdateLocalUserRequest
	if err := c.ShouldBindBodyWith(&request, binding.JSON); err != nil {
		c.JSON(http.StatusBadRequest, response.ValidationBadRequestMultiple(err))
		return
	}

	// Additional validation for name and username fields - prevent empty strings
	var validationErrors []response.ValidationError

	if request.Name != nil && strings.TrimSpace(*request.Name) == "" {
		validationErrors = append(validationErrors, response.ValidationError{
			Key:     "name",
			Message: "cannot_be_empty",
		})
	}

	if request.Username != nil && strings.TrimSpace(*request.Username) == "" {
		validationErrors = append(validationErrors, response.ValidationError{
			Key:     "username",
			Message: "cannot_be_empty",
		})
	}

	if len(validationErrors) > 0 {
		c.JSON(http.StatusBadRequest, response.ValidationFailed("validation failed", validationErrors))
		return
	}

	// Get current user context
	user, ok := helpers.GetUserFromContext(c)
	if !ok {
		return
	}

	// Get current user account for RBAC validation
	repo := entities.NewLocalUserRepository()
	currentAccount, err := repo.GetByID(userID)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			c.JSON(http.StatusNotFound, response.NotFound("user not found", nil))
			return
		}

		logger.Error().
			Err(err).
			Str("current_user_id", user.ID).
			Str("target_user_id", userID).
			Msg("Failed to get user for update validation")

		c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to get user", nil))
		return
	}

	// Apply RBAC validation
	userOrgRole := strings.ToLower(user.OrgRole)
	canUpdate := false

	// Users can always update themselves (with restrictions)
	if userID == user.ID {
		canUpdate = true
		// Users can only update certain fields about themselves
		// Organization-related fields should be restricted
		if request.OrganizationID != nil || request.UserRoleIDs != nil {
			c.JSON(http.StatusForbidden, response.Forbidden("users cannot modify their own organization or role information", nil))
			return
		}
	} else {
		// Check organization-based permissions for updating other users
		targetOrgID := ""
		if currentAccount.OrganizationID != nil {
			targetOrgID = *currentAccount.OrganizationID
		}

		service := local.NewUserService()
		if canUpdateUser, reason := service.CanUpdateUser(userOrgRole, user.OrganizationID, targetOrgID); canUpdateUser {
			canUpdate = true
		} else {
			c.JSON(http.StatusForbidden, response.Forbidden("access denied: "+reason, nil))
			return
		}
	}

	if !canUpdate {
		c.JSON(http.StatusForbidden, response.Forbidden("access denied to update user", nil))
		return
	}

	// Validate role assignment permissions if roles are being updated
	if request.UserRoleIDs != nil && len(*request.UserRoleIDs) > 0 {
		roleCache := cache.GetRoleNames()
		if !roleCache.IsLoaded() {
			logger.Error().
				Str("current_user_id", user.ID).
				Str("target_user_id", userID).
				Msg("Role cache not loaded - cannot validate role assignments")
			c.JSON(http.StatusInternalServerError, response.InternalServerError("role validation unavailable", nil))
			return
		}

		// Check each role being assigned
		for _, roleID := range *request.UserRoleIDs {
			accessControl, exists := roleCache.GetAccessControl(roleID)
			if exists && accessControl.HasAccessControl {
				// This role has access control restrictions
				hasPermission := HasOrgRolePermission(user.OrgRole, accessControl.RequiredOrgRole)
				if !hasPermission {
					logger.RequestLogger(c, "users").Warn().
						Str("operation", "role_assignment_denied").
						Str("current_user_id", user.ID).
						Str("current_user_org_role", user.OrgRole).
						Str("target_user_id", userID).
						Str("role_id", roleID).
						Str("required_org_role", accessControl.RequiredOrgRole).
						Msg("User attempted to assign role without sufficient privileges")

					c.JSON(http.StatusForbidden, response.Forbidden("insufficient privileges to assign this role", map[string]interface{}{
						"role_id":           roleID,
						"required_org_role": strings.ToLower(accessControl.RequiredOrgRole),
						"current_org_role":  strings.ToLower(user.OrgRole),
					}))
					return
				}

				logger.RequestLogger(c, "users").Debug().
					Str("operation", "role_assignment_validated").
					Str("current_user_id", user.ID).
					Str("current_user_org_role", user.OrgRole).
					Str("target_user_id", userID).
					Str("role_id", roleID).
					Str("required_org_role", accessControl.RequiredOrgRole).
					Msg("Role assignment validated successfully")
			}
		}
	}

	// Create service
	service := local.NewUserService()

	// Update user
	account, err := service.UpdateUser(userID, &request, user.ID, user.OrganizationID)
	if err != nil {
		logger.Error().
			Err(err).
			Str("current_user_id", user.ID).
			Str("target_user_id", userID).
			Msg("Failed to update user")

		// Check if it's a validation error from Logto
		if validationErr := getValidationError(err); validationErr != nil {
			c.JSON(http.StatusBadRequest, response.ValidationFailed("validation failed", validationErr.ErrorData.Errors))
			return
		}

		// Default to internal server error
		c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to update user", map[string]interface{}{
			"error": err.Error(),
		}))
		return
	}

	// Log the action
	logger.LogBusinessOperation(c, "users", "update", "user", userID, true, nil)

	// Return success response
	c.JSON(http.StatusOK, response.OK("user updated successfully", account))
}

// DeleteUser handles DELETE /api/users/:id - soft-deletes a user account locally and syncs to Logto
func DeleteUser(c *gin.Context) {
	// Get user ID from URL parameter
	userID := c.Param("id")
	if userID == "" {
		c.JSON(http.StatusBadRequest, response.BadRequest("user ID required", nil))
		return
	}

	// Get current user context
	user, ok := helpers.GetUserFromContext(c)
	if !ok {
		return
	}

	// Users cannot delete themselves
	if userID == user.ID {
		c.JSON(http.StatusForbidden, response.Forbidden("users cannot delete their own account", nil))
		return
	}

	// Get current user account for RBAC validation
	repo := entities.NewLocalUserRepository()
	currentAccount, err := repo.GetByID(userID)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			c.JSON(http.StatusNotFound, response.NotFound("user not found", nil))
			return
		}

		logger.Error().
			Err(err).
			Str("current_user_id", user.ID).
			Str("target_user_id", userID).
			Msg("Failed to get user for delete validation")

		c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to get user", nil))
		return
	}

	// Apply RBAC validation
	targetOrgID := ""
	if currentAccount.OrganizationID != nil {
		targetOrgID = *currentAccount.OrganizationID
	}

	userOrgRole := strings.ToLower(user.OrgRole)
	service := local.NewUserService()

	if canDelete, reason := service.CanDeleteUser(userOrgRole, user.OrganizationID, targetOrgID); !canDelete {
		c.JSON(http.StatusForbidden, response.Forbidden("access denied: "+reason, nil))
		return
	}

	// Delete user
	err = service.DeleteUser(userID, user.ID, user.OrganizationID)
	if err != nil {
		logger.Error().
			Err(err).
			Str("current_user_id", user.ID).
			Str("target_user_id", userID).
			Msg("Failed to delete user")

		c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to delete user", map[string]interface{}{
			"error": err.Error(),
		}))
		return
	}

	// Log the action
	logger.LogBusinessOperation(c, "users", "delete", "user", userID, true, nil)

	// Return success response
	c.JSON(http.StatusOK, response.OK("user deleted successfully", nil))
}

// SuspendUser handles PATCH /api/users/:id/suspend - suspends a user
func SuspendUser(c *gin.Context) {
	// Get user ID from URL parameter
	userID := c.Param("id")
	if userID == "" {
		c.JSON(http.StatusBadRequest, response.BadRequest("user ID required", nil))
		return
	}

	// Get current user context
	user, ok := helpers.GetUserFromContext(c)
	if !ok {
		return
	}

	// Users cannot suspend themselves
	if userID == user.ID {
		c.JSON(http.StatusForbidden, response.Forbidden("users cannot suspend themselves", nil))
		return
	}

	// Get target user to check permissions
	userRepo := entities.NewLocalUserRepository()
	targetUser, err := userRepo.GetByID(userID)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			c.JSON(http.StatusNotFound, response.NotFound("user not found", nil))
		} else {
			logger.Logger.Error().
				Str("component", "user-handler").
				Str("action", "get-target-user").
				Str("user_id", userID).
				Err(err).
				Msg("Failed to get target user for suspension")
			c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to get user", nil))
		}
		return
	}

	// Permission validation for suspension
	userService := local.NewUserService()
	userOrgRole := strings.ToLower(user.OrgRole)
	targetOrgID := ""
	if targetUser.OrganizationID != nil {
		targetOrgID = *targetUser.OrganizationID
	}
	canSuspend, reason := userService.CanSuspendUser(userOrgRole, user.OrganizationID, targetOrgID)
	if !canSuspend {
		c.JSON(http.StatusForbidden, response.Forbidden(reason, nil))
		return
	}

	// Suspend user
	err = userService.SuspendUser(userID, user.ID, user.OrganizationID)
	if err != nil {
		if strings.Contains(err.Error(), "not found or already suspended") {
			c.JSON(http.StatusBadRequest, response.BadRequest("user not found or already suspended", nil))
		} else {
			logger.Logger.Error().
				Str("component", "user-handler").
				Str("action", "suspend-user").
				Str("user_id", userID).
				Str("suspended_by", user.ID).
				Err(err).
				Msg("Failed to suspend user")
			c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to suspend user", nil))
		}
		return
	}

	// Blacklist all user tokens when suspended
	blacklist := cache.GetTokenBlacklist()
	blacklistErr := blacklist.BlacklistAllUserTokens(userID, "user suspended by administrator")
	if blacklistErr != nil {
		logger.RequestLogger(c, "users").Warn().
			Err(blacklistErr).
			Str("operation", "blacklist_suspended_user").
			Str("user_id", userID).
			Str("suspended_by", user.ID).
			Msg("Failed to blacklist suspended user tokens - user suspended but tokens still valid")
		// Don't fail the suspension if blacklist fails, just log warning
	} else {
		logger.RequestLogger(c, "users").Info().
			Str("operation", "tokens_blacklisted").
			Str("user_id", userID).
			Str("suspended_by", user.ID).
			Msg("All user tokens blacklisted due to suspension")
	}

	// Log the action
	logger.LogBusinessOperation(c, "users", "suspend", "user", userID, true, nil)

	// Return success response
	c.JSON(http.StatusOK, response.OK("user suspended successfully", nil))
}

// ReactivateUser handles PATCH /api/users/:id/reactivate - reactivates a suspended user
func ReactivateUser(c *gin.Context) {
	// Get user ID from URL parameter
	userID := c.Param("id")
	if userID == "" {
		c.JSON(http.StatusBadRequest, response.BadRequest("user ID required", nil))
		return
	}

	// Get current user context
	user, ok := helpers.GetUserFromContext(c)
	if !ok {
		return
	}

	// Get target user to check permissions
	userRepo := entities.NewLocalUserRepository()
	targetUser, err := userRepo.GetByID(userID)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			c.JSON(http.StatusNotFound, response.NotFound("user not found", nil))
		} else {
			logger.Logger.Error().
				Str("component", "user-handler").
				Str("action", "get-target-user").
				Str("user_id", userID).
				Err(err).
				Msg("Failed to get target user for reactivation")
			c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to get user", nil))
		}
		return
	}

	// Permission validation for reactivation (same as suspension)
	userService := local.NewUserService()
	userOrgRole := strings.ToLower(user.OrgRole)
	targetOrgID := ""
	if targetUser.OrganizationID != nil {
		targetOrgID = *targetUser.OrganizationID
	}
	canSuspend, reason := userService.CanSuspendUser(userOrgRole, user.OrganizationID, targetOrgID)
	if !canSuspend {
		c.JSON(http.StatusForbidden, response.Forbidden(reason, nil))
		return
	}

	// Reactivate user
	err = userService.ReactivateUser(userID, user.ID, user.OrganizationID)
	if err != nil {
		if strings.Contains(err.Error(), "not found or not suspended") {
			c.JSON(http.StatusBadRequest, response.BadRequest("user not found or not suspended", nil))
		} else {
			logger.Logger.Error().
				Str("component", "user-handler").
				Str("action", "reactivate-user").
				Str("user_id", userID).
				Str("reactivated_by", user.ID).
				Err(err).
				Msg("Failed to reactivate user")
			c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to reactivate user", nil))
		}
		return
	}

	// Remove user from token blacklist when reactivated
	blacklist := cache.GetTokenBlacklist()
	blacklistErr := blacklist.RemoveUserFromBlacklist(userID)
	if blacklistErr != nil {
		logger.RequestLogger(c, "users").Warn().
			Err(blacklistErr).
			Str("operation", "remove_user_from_blacklist").
			Str("user_id", userID).
			Str("reactivated_by", user.ID).
			Msg("Failed to remove user from token blacklist - user reactivated but old tokens still blocked")
		// Don't fail the reactivation if blacklist removal fails, just log warning
	} else {
		logger.RequestLogger(c, "users").Info().
			Str("operation", "user_removed_from_blacklist").
			Str("user_id", userID).
			Str("reactivated_by", user.ID).
			Msg("User removed from token blacklist due to reactivation")
	}

	// Log the action
	logger.LogBusinessOperation(c, "users", "reactivate", "user", userID, true, nil)

	// Return success response
	c.JSON(http.StatusOK, response.OK("user reactivated successfully", nil))
}

// ResetUserPassword handles PATCH /api/users/:id/password - resets user password
func ResetUserPassword(c *gin.Context) {
	// Get user ID from URL parameter
	userID := c.Param("id")
	if userID == "" {
		c.JSON(http.StatusBadRequest, response.BadRequest("user ID required", nil))
		return
	}

	// Parse request body for password (as per OpenAPI spec)
	var request struct {
		Password string `json:"password"`
	}
	if err := c.ShouldBindBodyWith(&request, binding.JSON); err != nil {
		c.JSON(http.StatusBadRequest, response.BadRequest("invalid request body", nil))
		return
	}

	// Validate password using our secure validator
	isValid, errorCodes := helpers.ValidatePasswordStrength(request.Password)
	if !isValid {
		c.JSON(http.StatusBadRequest, response.PasswordValidationBadRequest(errorCodes))
		return
	}

	// Get current user context
	user, ok := helpers.GetUserFromContext(c)
	if !ok {
		return
	}

	// Get target user account for RBAC validation
	repo := entities.NewLocalUserRepository()
	targetAccount, err := repo.GetByID(userID)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			c.JSON(http.StatusNotFound, response.NotFound("user not found", nil))
			return
		}

		logger.Error().
			Err(err).
			Str("current_user_id", user.ID).
			Str("target_user_id", userID).
			Msg("Failed to get user for password reset")

		c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to get user", nil))
		return
	}

	// Apply RBAC validation - similar to update but more restrictive
	userOrgRole := strings.ToLower(user.OrgRole)
	canReset := false

	// Users can reset their own password
	if userID == user.ID {
		canReset = true
	} else {
		// Only higher-level roles can reset other users' passwords
		targetOrgID := ""
		if targetAccount.OrganizationID != nil {
			targetOrgID = *targetAccount.OrganizationID
		}

		switch userOrgRole {
		case "owner":
			canReset = true
		case "distributor":
			// Distributor can reset passwords in organizations they manage
			if targetOrgID == user.OrganizationID {
				canReset = true
			}
		case "reseller":
			// Reseller can reset passwords in their organization
			if targetOrgID == user.OrganizationID {
				canReset = true
			}
		case "customer":
			// Customer can reset passwords in their organization
			if targetOrgID == user.OrganizationID {
				canReset = true
			}
		}
	}

	if !canReset {
		c.JSON(http.StatusForbidden, response.Forbidden("access denied to reset password", nil))
		return
	}

	// Check if user is synced to Logto
	if targetAccount.LogtoID == nil {
		c.JSON(http.StatusBadRequest, response.BadRequest("user not synced to Logto", nil))
		return
	}

	// Create service and reset password using Logto ID
	service := local.NewUserService()
	err = service.ResetUserPassword(*targetAccount.LogtoID, request.Password)
	if err != nil {
		logger.Error().
			Err(err).
			Str("current_user_id", user.ID).
			Str("target_user_id", userID).
			Str("logto_user_id", *targetAccount.LogtoID).
			Msg("Failed to reset user password")

		// Check if it's a validation error from Logto (same as other endpoints)
		if validationErr := getValidationError(err); validationErr != nil {
			c.JSON(http.StatusBadRequest, response.ValidationFailed("validation failed", validationErr.ErrorData.Errors))
			return
		}

		// Default to internal server error for non-validation errors
		c.JSON(http.StatusInternalServerError, response.InternalServerError("failed to reset password", map[string]interface{}{
			"error": err.Error(),
		}))
		return
	}

	// Log the action
	logger.LogBusinessOperation(c, "users", "password_reset", "user", userID, true, nil)

	// Return success response
	c.JSON(http.StatusOK, response.OK("password reset successfully", nil))
}

// getValidationError checks if the error chain contains a ValidationError and returns it
func getValidationError(err error) *local.ValidationError {
	var validationErr *local.ValidationError
	if errors.As(err, &validationErr) {
		return validationErr
	}
	return nil
}
