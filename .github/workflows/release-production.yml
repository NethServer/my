name: Release - Production

on:
  push:
    tags:
      - 'v*.*.*'

env:
  REGISTRY: ghcr.io

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'
        cache: false

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    # Quality checks before release
    - name: Check code formatting (backend)
      working-directory: backend
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "Code is not formatted properly in backend:"
          gofmt -s -l .
          exit 1
        fi

    - name: Check code formatting (sync)
      working-directory: sync
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "Code is not formatted properly in sync:"
          gofmt -s -l .
          exit 1
        fi

    - name: Check code formatting (collect)
      working-directory: collect
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "Code is not formatted properly in collect:"
          gofmt -s -l .
          exit 1
        fi

    - name: Run backend linting
      uses: golangci/golangci-lint-action@v6
      with:
        version: latest
        working-directory: backend
        args: --timeout=10m

    - name: Run sync linting
      uses: golangci/golangci-lint-action@v6
      with:
        version: latest
        working-directory: sync
        args: --timeout=10m

    - name: Run collect linting
      uses: golangci/golangci-lint-action@v6
      with:
        version: latest
        working-directory: collect
        args: --timeout=10m

    - name: Run backend tests
      working-directory: backend
      run: go test ./...

    - name: Run sync tests
      working-directory: sync
      run: go test ./...

    - name: Run collect tests
      working-directory: collect
      run: go test ./...

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      working-directory: frontend
      run: npm ci

    - name: Check frontend formatting
      working-directory: frontend
      run: npm run format

    - name: Run frontend linting
      working-directory: frontend
      run: npm run lint

    - name: Run frontend type checking
      working-directory: frontend
      run: npm run type-check

    - name: Run frontend tests
      working-directory: frontend
      run: npm run test

    - name: Test frontend build
      working-directory: frontend
      run: npm run build

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract version
      id: version
      run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    # Backend Release
    - name: Build backend binary
      working-directory: backend
      run: |
        mkdir -p dist

        VERSION="${{ steps.version.outputs.VERSION }}"
        COMMIT="${{ github.sha }}"
        BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        LDFLAGS="-s -w -X github.com/nethesis/my/backend/pkg/version.Version=${VERSION} -X github.com/nethesis/my/backend/pkg/version.Commit=${COMMIT} -X github.com/nethesis/my/backend/pkg/version.BuildTime=${BUILD_TIME}"

        GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="${LDFLAGS}" -o dist/backend-linux-amd64 main.go
        GOOS=linux GOARCH=arm64 CGO_ENABLED=0 go build -ldflags="${LDFLAGS}" -o dist/backend-linux-arm64 main.go
        GOOS=darwin GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="${LDFLAGS}" -o dist/backend-darwin-amd64 main.go
        GOOS=darwin GOARCH=arm64 CGO_ENABLED=0 go build -ldflags="${LDFLAGS}" -o dist/backend-darwin-arm64 main.go

        cd dist
        tar -czf backend-linux-amd64.tar.gz backend-linux-amd64
        tar -czf backend-linux-arm64.tar.gz backend-linux-arm64
        tar -czf backend-darwin-amd64.tar.gz backend-darwin-amd64
        tar -czf backend-darwin-arm64.tar.gz backend-darwin-arm64

    # Collect Release
    - name: Build collect binary
      working-directory: collect
      run: |
        mkdir -p dist

        VERSION="${{ steps.version.outputs.VERSION }}"
        COMMIT="${{ github.sha }}"
        BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        LDFLAGS="-s -w -X github.com/nethesis/my/collect/pkg/version.Version=${VERSION} -X github.com/nethesis/my/collect/pkg/version.Commit=${COMMIT} -X github.com/nethesis/my/collect/pkg/version.BuildTime=${BUILD_TIME}"

        GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="${LDFLAGS}" -o dist/collect-linux-amd64 main.go
        GOOS=linux GOARCH=arm64 CGO_ENABLED=0 go build -ldflags="${LDFLAGS}" -o dist/collect-linux-arm64 main.go
        GOOS=darwin GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="${LDFLAGS}" -o dist/collect-darwin-amd64 main.go
        GOOS=darwin GOARCH=arm64 CGO_ENABLED=0 go build -ldflags="${LDFLAGS}" -o dist/collect-darwin-arm64 main.go

        cd dist
        tar -czf collect-linux-amd64.tar.gz collect-linux-amd64
        tar -czf collect-linux-arm64.tar.gz collect-linux-arm64
        tar -czf collect-darwin-amd64.tar.gz collect-darwin-amd64
        tar -czf collect-darwin-arm64.tar.gz collect-darwin-arm64

    # Sync Release
    - name: Build sync binary
      working-directory: sync
      run: |
        mkdir -p dist

        VERSION="${{ steps.version.outputs.VERSION }}"
        COMMIT="${{ github.sha }}"
        BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        LDFLAGS="-s -w -X github.com/nethesis/my/sync/pkg/version.Version=${VERSION} -X github.com/nethesis/my/sync/pkg/version.Commit=${COMMIT} -X github.com/nethesis/my/sync/pkg/version.BuildTime=${BUILD_TIME}"

        GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="${LDFLAGS}" -o dist/sync-linux-amd64 ./cmd/sync/main.go
        GOOS=linux GOARCH=arm64 CGO_ENABLED=0 go build -ldflags="${LDFLAGS}" -o dist/sync-linux-arm64 ./cmd/sync/main.go
        GOOS=darwin GOARCH=amd64 CGO_ENABLED=0 go build -ldflags="${LDFLAGS}" -o dist/sync-darwin-amd64 ./cmd/sync/main.go
        GOOS=darwin GOARCH=arm64 CGO_ENABLED=0 go build -ldflags="${LDFLAGS}" -o dist/sync-darwin-arm64 ./cmd/sync/main.go

        cd dist
        for binary in sync-*; do
          if [[ "$binary" != *.tar.gz ]]; then
            mkdir -p "${binary}-release"
            cp "$binary" "${binary}-release/sync"
            cp -r ../configs "${binary}-release/"
            tar -czf "${binary}.tar.gz" "${binary}-release"
            rm -rf "${binary}-release"
          fi
        done

    # Docker Images with multi-platform support
    - name: Extract backend metadata
      id: backend_meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}/backend
        tags: |
          type=semver,pattern=v{{version}},value=${{ steps.version.outputs.VERSION }}
          type=raw,value=latest

    - name: Build and push backend Docker image
      uses: docker/build-push-action@v5
      with:
        context: backend
        file: backend/Containerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.backend_meta.outputs.tags }}
        labels: |
          ${{ steps.backend_meta.outputs.labels }}
          org.opencontainers.image.title=My Nethesis Backend
          org.opencontainers.image.description=Backend API for My Nethesis
        cache-from: type=gha,scope=backend
        cache-to: type=gha,mode=max,scope=backend
        build-args: |
          VERSION=${{ steps.version.outputs.VERSION }}
          COMMIT=${{ github.sha }}
          BUILD_TIME=${{ steps.backend_meta.outputs.labels['org.opencontainers.image.created'] }}

    - name: Wait for backend image availability
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ github.repository }}/backend:${{ steps.version.outputs.VERSION }}"
        for i in $(seq 1 10); do
          docker manifest inspect "$IMAGE" > /dev/null 2>&1 && { echo "Image available"; exit 0; }
          echo "Waiting for image... (attempt $i/10)"
          sleep 5
        done
        echo "Image not available after 50s, proceeding anyway"

    - name: Generate backend SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ github.repository }}/backend:${{ steps.version.outputs.VERSION }}
        format: cyclonedx-json
        output-file: backend-sbom.cdx.json

    - name: Extract sync metadata
      id: sync_meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}/sync
        tags: |
          type=semver,pattern=v{{version}},value=${{ steps.version.outputs.VERSION }}
          type=raw,value=latest

    - name: Build and push sync Docker image
      uses: docker/build-push-action@v5
      with:
        context: sync
        file: sync/Containerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.sync_meta.outputs.tags }}
        labels: |
          ${{ steps.sync_meta.outputs.labels }}
          org.opencontainers.image.title=My Nethesis Sync
          org.opencontainers.image.description=CLI tool for syncing RBAC configuration with Logto
        cache-from: type=gha,scope=sync
        cache-to: type=gha,mode=max,scope=sync
        build-args: |
          VERSION=${{ steps.version.outputs.VERSION }}
          COMMIT=${{ github.sha }}
          BUILD_TIME=${{ steps.sync_meta.outputs.labels['org.opencontainers.image.created'] }}

    - name: Wait for sync image availability
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ github.repository }}/sync:${{ steps.version.outputs.VERSION }}"
        for i in $(seq 1 10); do
          docker manifest inspect "$IMAGE" > /dev/null 2>&1 && { echo "Image available"; exit 0; }
          echo "Waiting for image... (attempt $i/10)"
          sleep 5
        done
        echo "Image not available after 50s, proceeding anyway"

    - name: Generate sync SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ github.repository }}/sync:${{ steps.version.outputs.VERSION }}
        format: cyclonedx-json
        output-file: sync-sbom.cdx.json

    - name: Extract collect metadata
      id: collect_meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}/collect
        tags: |
          type=semver,pattern=v{{version}},value=${{ steps.version.outputs.VERSION }}
          type=raw,value=latest

    - name: Build and push collect Docker image
      uses: docker/build-push-action@v5
      with:
        context: collect
        file: collect/Containerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.collect_meta.outputs.tags }}
        labels: |
          ${{ steps.collect_meta.outputs.labels }}
          org.opencontainers.image.title=My Nethesis Collect
          org.opencontainers.image.description=Collection service for My Nethesis
        cache-from: type=gha,scope=collect
        cache-to: type=gha,mode=max,scope=collect
        build-args: |
          VERSION=${{ steps.version.outputs.VERSION }}
          COMMIT=${{ github.sha }}
          BUILD_TIME=${{ steps.collect_meta.outputs.labels['org.opencontainers.image.created'] }}

    - name: Wait for collect image availability
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ github.repository }}/collect:${{ steps.version.outputs.VERSION }}"
        for i in $(seq 1 10); do
          docker manifest inspect "$IMAGE" > /dev/null 2>&1 && { echo "Image available"; exit 0; }
          echo "Waiting for image... (attempt $i/10)"
          sleep 5
        done
        echo "Image not available after 50s, proceeding anyway"

    - name: Generate collect SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ github.repository }}/collect:${{ steps.version.outputs.VERSION }}
        format: cyclonedx-json
        output-file: collect-sbom.cdx.json

    - name: Extract frontend metadata
      id: frontend_meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}/frontend
        tags: |
          type=semver,pattern=v{{version}},value=${{ steps.version.outputs.VERSION }}
          type=raw,value=latest

    - name: Build and push frontend Docker image
      uses: docker/build-push-action@v5
      with:
        context: frontend
        file: frontend/Containerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.frontend_meta.outputs.tags }}
        labels: |
          ${{ steps.frontend_meta.outputs.labels }}
          org.opencontainers.image.title=My Nethesis Frontend
          org.opencontainers.image.description=Frontend web application for My Nethesis
        cache-from: type=gha,scope=frontend
        cache-to: type=gha,mode=max,scope=frontend

    - name: Wait for frontend image availability
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ github.repository }}/frontend:${{ steps.version.outputs.VERSION }}"
        for i in $(seq 1 10); do
          docker manifest inspect "$IMAGE" > /dev/null 2>&1 && { echo "Image available"; exit 0; }
          echo "Waiting for image... (attempt $i/10)"
          sleep 5
        done
        echo "Image not available after 50s, proceeding anyway"

    - name: Generate frontend SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ github.repository }}/frontend:${{ steps.version.outputs.VERSION }}
        format: cyclonedx-json
        output-file: frontend-sbom.cdx.json

    - name: Extract proxy metadata
      id: proxy_meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}/proxy
        tags: |
          type=semver,pattern=v{{version}},value=${{ steps.version.outputs.VERSION }}
          type=raw,value=latest

    - name: Build and push proxy Docker image
      uses: docker/build-push-action@v5
      with:
        context: proxy
        file: proxy/Containerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.proxy_meta.outputs.tags }}
        labels: |
          ${{ steps.proxy_meta.outputs.labels }}
          org.opencontainers.image.title=My Nethesis Proxy
          org.opencontainers.image.description=Reverse proxy for My Nethesis
        cache-from: type=gha,scope=proxy
        cache-to: type=gha,mode=max,scope=proxy

    - name: Wait for proxy image availability
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ github.repository }}/proxy:${{ steps.version.outputs.VERSION }}"
        for i in $(seq 1 10); do
          docker manifest inspect "$IMAGE" > /dev/null 2>&1 && { echo "Image available"; exit 0; }
          echo "Waiting for image... (attempt $i/10)"
          sleep 5
        done
        echo "Image not available after 50s, proceeding anyway"

    - name: Generate proxy SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ github.repository }}/proxy:${{ steps.version.outputs.VERSION }}
        format: cyclonedx-json
        output-file: proxy-sbom.cdx.json

    - name: Extract mimir metadata
      id: mimir_meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ github.repository }}/mimir
        tags: |
          type=semver,pattern=v{{version}},value=${{ steps.version.outputs.VERSION }}
          type=raw,value=latest

    - name: Build and push mimir Docker image
      uses: docker/build-push-action@v5
      with:
        context: services/mimir
        file: services/mimir/Containerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.mimir_meta.outputs.tags }}
        labels: |
          ${{ steps.mimir_meta.outputs.labels }}
          org.opencontainers.image.title=My Nethesis Mimir
          org.opencontainers.image.description=Grafana Mimir metrics backend for My Nethesis
        cache-from: type=gha,scope=mimir
        cache-to: type=gha,mode=max,scope=mimir

    - name: Wait for mimir image availability
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ github.repository }}/mimir:${{ steps.version.outputs.VERSION }}"
        for i in $(seq 1 10); do
          docker manifest inspect "$IMAGE" > /dev/null 2>&1 && { echo "Image available"; exit 0; }
          echo "Waiting for image... (attempt $i/10)"
          sleep 5
        done
        echo "Image not available after 50s, proceeding anyway"

    - name: Generate mimir SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ github.repository }}/mimir:${{ steps.version.outputs.VERSION }}
        format: cyclonedx-json
        output-file: mimir-sbom.cdx.json

    # Create GitHub Release
    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        generate_release_notes: true
        files: |
          backend/dist/*.tar.gz
          sync/dist/*.tar.gz
          collect/dist/*.tar.gz
          backend-sbom.cdx.json
          sync-sbom.cdx.json
          collect-sbom.cdx.json
          frontend-sbom.cdx.json
          proxy-sbom.cdx.json
          mimir-sbom.cdx.json
